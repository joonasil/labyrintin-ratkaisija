# Testausdokumentaatio

Ohjelman testauksessa on käytetty JUnit testejä tietorakenteiden ja algoritmien toiminnan testaamiseen ja Käyttöliittymään sisäänrakennettua datankeräys toimintoa aikavaativuustestaukseen ja -vertailuun. JUnit testeistä on tehty mutaatiotestejä käyttäen pit:tiä. Dokumentaatiossa on vanha pit raportti, koska jostain syystä pit hajosi eikä suostu generoimaan enää uutta raporttia. Kaikki JUnit testit menevät läpi yksittäin ja yhdessä, mutta kun yritän generoida pit raporttia saan virheen, joka väittää ettei PriorityQueue luokan testit mene läpi edes ilman mutaatiota.  
  
Suorituskykytestauksessa on käytetty ohjelman omaa datankeräysohjelmaa, joka generoi määrätyn määrän labyrintteja ja tallentaa generointi- ja ratkaisualgoritmien käyttämän ajan taulukkoon, jonka voi tallentaa suoraan .csv tiedostoksi yhdellä napinpainauksella. Tätä toimintoa käyttäen generoin tietyn kokoisia labyrintteja niin paljon, kuin jaksoin kussakin koossa odottaa ja otin saaduista arvoista mediaanin, jotta suuret yksittäiset vaihtelut eivät vaikuttaisi niin paljoa tuloksiin. Esimerkiksi ohjelmalla kestää aina keskivertoa huomattavasti kauemmin luoda ensimmäinen labyrintti. Kyseessä on varmaan jotain muistinhallintaan liittyvää, koska uusi samankokoinen labyrintti käyttää yhtä paljon muistia kuin edellinen, niin ohjelman pitäisi pystyä käyttämään samaa muistialuetta uudelle labyrintille.  
  
Ohjelman kolme labyrintin generointialgoritmia luovat jokainen eri typpisiä labyrintteja. Primin algoritmilla generoiduissa labyrinteissä on suurin haarautumiskerroin ja lyhyimmät ratkaisut, depth-first search algoritmin luomissa labyrinteissa taas on hyvin pieni haarautumiskerroin ja pisimmät ratkaisut. Kruskalin algoritmilla generoidut labyrintit ovat kahden muun algoritmin väliltä, niissä on keskinkertainen haarautumiskerroin ja lyhyin ratkaisu. Jokaisen algoritmin generoimissa labyrinteissa on vain yksi ratkaisu minkä tahansa kahden pisteen välillä. Koska ratkaisualgoritmien aikavaativuudet riippuvat lyhyimmän reitin pituudesta ja haarautumiskertoimesta, on eri labyrinteista saadut tulokset mielenkiintoisia.

###Breadth-first search

![BFS](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/BFSKoko.png)
![BFS](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/BFSReitti.png)  
Breadth-first search algoritmilla ei ole mitään heuristiikkaa, vaan se tutkii kasvavassa järjestyksessä kaikki tietyn mittaiset reitit. Tästä johtuen kun katsoo kuvaajaa, jossa algoritmin kestoa on verrattu labyrintin kokoon nähdään että riippumatta siitä miten labyrintti on generoitu, käy algoritmi suunnilleen yhtä monessa labyrintin ruudussa. Kun taas katsoo kuvaajaa, jossa on algoritmin kestoa verrataan lyhyimmän reitin pituuteen, nähdään että pienempi haarautumiskerroin labyrintissa, jossa on saman kokoinen lyhyin reitti pienentää algoritmin vaatimaa aikaa. Breadth-first search on keskivertaisesti nopein ratkaisemaan depth-first search algoritmilla generoituja labyrintteja. Olisi ollut mielenkiintoista lisätä mahdollisuus laskea labyrintin haarautumiskerroin, jolloin olisi paremmin päässyt testaamaan aikavaativuutta O(b^d-1), missä b on haarautumiskerroin ja d lyhyimmän reitin pituus. 

###A-Star

![A-Star](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/AStarKoko.png)
![A-Star](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/AStarReitti.png)  
A-Star algoritmi käyttää heuristiikkaa karsiakseen algoritmin käymiä solmuja ja labyrintin kokoon verrattaessa nähdään, että A-Star hyötyy eniten mahdollisimman suuresta haarautumiskertoimesta jolloin myös on mahdollista karsia enemmän solmuja pois. Kun taas vertaamme algoritmin viemää aikaa reitin pituuteen, nähdään taas ettei suuri haarautumiskerroin ole pelkästään hyvä asia sillä taas jos vain lyhin reitti on saman mittainen, on pienimmän haarautumiskertoimen omaava labyrintti nopein ratkaistava. A-Star on yleensä nopein ratkaisemaan Kruskalin algoritmilla generoituja labyrintteja ja yhtä nopea ratkaisemaan depth-first search algoritmilla generoituja labyrintteja kuin breadth-first search algoritmi.

###Iterative deepening A-Star
![IDA](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/IDAKoko.png)
![IDA](https://github.com/joonasil/labyrintin-ratkaisija/blob/master/Dokumentaatio/Kuvia/IDAReitti.png)  
Iterative deepening A-Star algoritmi on nopeampi käymään yksittäisiä ruutuja läpi kuin perinteinen A-Star, koska se ei tarvitse prioriteettijonoa vaan toteutetaan rekursiivisesti. Tästä johtuen jos labyrintin haarautumisaste on tarpeeksi suuri ja lyhyin reitti suhteellisen suora, käy algoritmi läpi suunnilleen saman verran ruutuja kuin A-Star, mutta tekee sen ajassa O(n) A-Starin O(n log n) sijaan. Näin ollen iterative deepening A-Star on yleensä nopein algoritmi ratkaisemaan Primin algoritmilla generoituja labyrintteja. 
